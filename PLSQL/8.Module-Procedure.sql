-- Variable & Print
VARIABLE H_SALARY NUMBER;
VARIABLE H_TAX NUMBER;
VARIABLE;

DECLARE
    C_TAX_RATE NUMBER(2, 3);
BEGIN
    C_TAX_RATE := 0.05;
    :H_SALARY := 1000;
    :H_TAX := ROUND((:H_SALARY * C_TAX_RATE), 2);
END;
/

PRINT H_SALARY;
PRINT H_TAX;

HELP PRINT
HELP VARIABLE
VARIABLE V_ENAME VARCHAR2(10);
VARIABLE V_ENAME;
VARIABLE;

-- Procedure
CREATE OR REPLACE PROCEDURE CHANGE_SALARY(A_EMPNO IN NUMBER, A_SALARY NUMBER DEFAULT 2000)
AS
BEGIN
	UPDATE EMP -- 트랜잭션 시작
	SET SAL = A_SALARY WHERE EMPNO = A_EMPNO;
	COMMIT; -- 트랜잭션 종료
END CHANGE_SALARY; 
/

DESC CHANGE_SALARY;
VARIABLE P_EMPNO NUMBER;
VARIABLE P_SALARY NUMBER;

BEGIN
	:P_EMPNO := 7369;
	:P_SALARY := 7369;
	CHANGE_SALARY(:P_EMPNO, :P_SALARY);
END;
/

SELECT EMPNO,SAL FROM EMP WHERE EMPNO = 7369;

EXECUTE CHANGE_SALARY(:P_EMPNO);
SELECT EMPNO,SAL FROM EMP WHERE EMPNO = 7369;


-- 예외처리의 필요성
SET SERVEROUTPUT ON;

CREATE OR REPLACE PROCEDURE CHANGE_SALARY(A_EMPNO IN NUMBER , A_SALARY NUMBER DEFAULT 2000 )
AS

BEGIN
	UPDATE EMP
	SET SAL = A_SALARY WHERE EMPNO = A_EMPNO;
	COMMIT;

EXCEPTION
	WHEN VALUE_ERROR THEN
		DBMS_OUTPUT.PUT_LINE('VALUE_ERROR => '||SQLERRM); -- 실제 운영시 사용 ??
		NULL;
	WHEN NO_DATA_FOUND THEN
		DBMS_OUTPUT.PUT_LINE('NO_DATA_FOUND => '||SQLERRM);
		ROLLBACK;
	WHEN OTHERS THEN
		DBMS_OUTPUT.PUT_LINE('OTHERS =>: '||SQLERRM);
		ROLLBACK;

END CHANGE_SALARY; 
/

-- prameter 이름과 값을 매핑하여 대입 가능!
-- Exception 처리결과가 안보이는 이유는? : 큰 값
EXECUTE CHANGE_SALARY(A_EMPNO => 7369 , A_SALARY => 1234);
SELECT EMPNO,SAL FROM EMP WHERE EMPNO = 7369;

-- PL/SQL MODULE & LOG
-- REM EXCCEPTION 발생을 기록하는 LOG 테이블 생성
CREATE TABLE EXCEPTION_LOG
(
	LOG_DATE VARCHAR2(8) DEFAULT TO_CHAR(SYSDATE,'YYYYMMD'), -- 로그 기록 일자 YYYYMMDD
	LOG_TIME VARCHAR2(6) DEFAULT TO_CHAR(SYSDATE,'HH24MISS'), -- 로그 기록 시간 HH24MISS
	PROGRAM_NAME VARCHAR2(100), -- EXCEPTION 발생 프로그램
	ERROR_MESSAGE VARCHAR2(250), -- EXCEPTION MESSAGE
	DESCRIPTION VARCHAR2(250) -- 비고 사항
);

-- EXCEPTION 처리 프로시저
CREATE OR REPLACE PROCEDURE CHANGE_SALARY(A_EMPNO IN NUMBER , A_SALARY NUMBER DEFAULT 2000 )
AS
	V_ERROR_MESSAGE EXCEPTION_LOG.ERROR_MESSAGE%TYPE; -- 에러메세지
BEGIN
	UPDATE EMP SET SAL = A_SALARY WHERE EMPNO = A_EMPNO;
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		BEGIN -- EXCEPTION을 LOG 테이블에 기록
			V_ERROR_MESSAGE := SQLERRM;
			INSERT INTO EXCEPTION_LOG(PROGRAM_NAME,ERROR_MESSAGE,DESCRIPTION)
			VALUES('CHANGE_SALARY',V_ERROR_MESSAGE, 'VALUES : [1]=>'||A_EMPNO||' [2]=>'||A_SALARY);
			COMMIT; -- plsql autonomous transaction 찾아서 정리
		EXCEPTION
			WHEN OTHERS THEN
				NULL; -- NULL 명령어이다. -- 대안은?
		END;
END CHANGE_SALARY; 
/
-- begin ~ end 변환 처리 -- 자리수 초과 Exception 발생->log 테이블에 데이터 기록
EXECUTE CHANGE_SALARY(A_EMPNO => 7369 , A_SALARY => 1234567); 
SELECT * FROM EXCEPTION_LOG;

-- 공통 라이브러리화
CREATE OR REPLACE PROCEDURE
WRITE_LOG(A_PROGRAM_NAME IN VARCHAR2,A_ERROR_MESSAGE IN VARCHAR2,A_DESCRIPTION IN VARCHAR2)
AS
BEGIN
	-- EXCEPTION을 LOG 테이블에 기록
	INSERT INTO EXCEPTION_LOG(PROGRAM_NAME,ERROR_MESSAGE,DESCRIPTION)
	VALUES(A_PROGRAM_NAME,A_ERROR_MESSAGE,A_DESCRIPTION);
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		NULL; -- 대안은?
END;
/

CREATE OR REPLACE PROCEDURE CHANGE_SALARY(A_EMPNO IN NUMBER , A_SALARY NUMBER DEFAULT 2000 )
AS
	V_ERROR_MESSAGE EXCEPTION_LOG.ERROR_MESSAGE%TYPE; -- 에러메세지
BEGIN
	UPDATE EMP SET SAL = A_SALARY WHERE EMPNO = A_EMPNO;
	COMMIT;
EXCEPTION
	WHEN OTHERS THEN
		ROLLBACK;
		WRITE_LOG('CHANGE_SALARY',SQLERRM,'VALUES : [1]=>'||A_EMPNO||' [2]=>'||A_SALARY);
END CHANGE_SALARY;
/

EXECUTE CHANGE_SALARY(A_EMPNO => 7369 , A_SALARY => 1234567); 
SELECT * FROM EXCEPTION_LOG;