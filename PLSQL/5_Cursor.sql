-- 1. 암시적 커서 속성 실습
SET SERVEROUTPUT ON
BEGIN
	-- 첫번째 DELETE
	DELETE FROM EMP WHERE SAL > 2000;
	DBMS_OUTPUT.PUT_LINE('[1-DELETE]'||TO_CHAR(SQL%ROWCOUNT)||'ROWS IS DELETED'); -- SQL%ROWCOUNT는 3을 리턴
	IF SQL%FOUND THEN
		DBMS_OUTPUT.PUT_LINE('SQL%FOUND = TRUE ');
	ELSE
		DBMS_OUTPUT.PUT_LINE('SQL%NOTFOUND = FALSE ');
	END IF;
	DBMS_OUTPUT.PUT_LINE('-------------------------------------------------');
	-- 두번째 DELETE : 동일한 DELETE 를 2번째 실행하므로 삭제할 데이타가 없음
	DELETE FROM EMP WHERE SAL > 2000;
	DBMS_OUTPUT.PUT_LINE('[2-DELETE]'||TO_CHAR(SQL%ROWCOUNT)||'ROWS IS DELETED');
	IF SQL%FOUND THEN
		DBMS_OUTPUT.PUT_LINE('SQL%FOUND = TRUE');
	ELSE
		DBMS_OUTPUT.PUT_LINE('SQL%NOTFOUND = FALSE');
	END IF;
	ROLLBACK;
END;
/

-- 2. 명시적 커서 속성 실습 ( 주말과제 활용 )
TRUNCATE TABLE BONUS; -- DDL
DECLARE
	CURSOR CUR_EMP IS -- 결과 집합의 이름 : CUR_EMP
		SELECT EMPNO,JOB,SAL,COMM FROM EMP WHERE DEPTNO = 10;
	V_ENAME VARCHAR2(10);
	V_JOB VARCHAR2(9);
	V_SAL NUMBER(7,2);
	V_COMM NUMBER(7,2);
BEGIN
	OPEN CUR_EMP; -- 커서 열기
	LOOP
		FETCH CUR_EMP INTO V_ENAME, V_JOB, V_SAL, V_COMM ;
		EXIT WHEN CUR_EMP%NOTFOUND; -- 커서에서 더이상 fetch할 게 없으면, EXIT
		-- Business Logic
		INSERT INTO BONUS(ENAME,JOB,SAL,COMM) VALUES(V_ENAME,V_JOB,V_SAL,V_COMM);
	END LOOP;
    -- 명시적 커서에서의 ROWCOUNT는 누적된 값
    DBMS_OUTPUT.PUT_LINE('TOTAL '||TO_CHAR(CUR_EMP%ROWCOUNT)||' rows processed');
	CLOSE CUR_EMP; -- 자원 반납
	COMMIT;
	END;
/

SELECT * FROM BONUS;

-- 3. (Column) 참조 변수
TRUNCATE TABLE BONUS;
SET SERVEROUTPUT ON
DECLARE
	CURSOR CUR_EMP IS
		SELECT ENAME,JOB,SAL,COMM FROM EMP WHERE DEPTNO = 10;
	V_ENAME EMP.ENAME%TYPE;
	V_JOB EMP.JOB%TYPE;
	V_SAL EMP.SAL%TYPE;
	V_COMM EMP.COMM%TYPE;
BEGIN
	OPEN CUR_EMP;
	LOOP
		FETCH CUR_EMP INTO V_ENAME,V_JOB,V_SAL,V_COMM ;
		EXIT WHEN CUR_EMP%NOTFOUND;
		INSERT INTO BONUS(ENAME,JOB,SAL,COMM) VALUES(V_ENAME,V_JOB,V_SAL,V_COMM);
	END LOOP;
		DBMS_OUTPUT.PUT_LINE('TOTAL '||TO_CHAR(CUR_EMP%ROWCOUNT)||' rows processed');
	CLOSE CUR_EMP;
	COMMIT;
END;
/

SELECT * FROM BONUS;

-- 4. (Row) 참조 변수
TRUNCATE TABLE BONUS;
SET SERVEROUTPUT ON
DECLARE
	CURSOR CUR_EMP IS
		SELECT ENAME,JOB,SAL,COMM FROM EMP WHERE DEPTNO = 10;
-- %ROWTYPE이용 선언한 Cursor를 참조해서 변수를 만듦.
-- 자동으로 4개의 필드를 가지고 레코드를 정의함
	R_CUR_EMP CUR_EMP%ROWTYPE; 
BEGIN
	OPEN CUR_EMP;
	LOOP
		FETCH CUR_EMP INTO R_CUR_EMP;
		EXIT WHEN CUR_EMP%NOTFOUND;
		INSERT INTO BONUS(ENAME,JOB,SAL,COMM)
			VALUES(R_CUR_EMP.ENAME,R_CUR_EMP.JOB,R_CUR_EMP.SAL,R_CUR_EMP.COMM);
	END LOOP;
		DBMS_OUTPUT.PUT_LINE('TOTAL '||TO_CHAR(CUR_EMP%ROWCOUNT)||' rows processed');
	CLOSE CUR_EMP;
	COMMIT;
END;
/

SELECT * FROM BONUS;

-- 5. Cursor for loop
TRUNCATE TABLE BONUS;
SET SERVEROUTPUT ON;
DECLARE
    CURSOR CUR_EMP IS
        SELECT ENAME, JOB, SAL, COMM FROM EMP WHERE DEPTNO = 10;
BEGIN
    FOR R_CUR_EMP IN CUR_EMP
    LOOP
        INSERT INTO BONUS(ENAME, JOB, SAL, COMM)
            VALUES(R_CUR_EMP.ENAME, R_CUR_EMP.JOB, R_CUR_EMP.SAL, R_CUR_EMP.COMM);
    END LOOP;
    -- DBMS_OUTPUT.PUT_LINE('TOTAL '||TO_CHAR(CUR_EMP%ROWCOUNT)||' rows processed’); -- Error?
    COMMIT;
END;
/
SELECT * FROM BONUS;

-- 6. Cursor for loop2
TRUNCATE TABLE BONUS;
SET SERVEROUTPUT ON

BEGIN
	FOR R_CUR_EMP IN (SELECT ENAME,JOB,SAL,COMM FROM EMP WHERE DEPTNO = 10)
	LOOP
		INSERT INTO BONUS(ENAME,JOB,SAL,COMM)
		VALUES(R_CUR_EMP.ENAME,R_CUR_EMP.JOB,R_CUR_EMP.SAL,R_CUR_EMP.COMM);
	END LOOP;
	COMMIT;
END;
/
SELECT * FROM BONUS;

-- 7. Cursor Parameter
TRUNCATE TABLE BONUS;
DECLARE
	CURSOR CUR_EMP(P_DEPTNO IN NUMBER) IS -- Parameter 정의함. data type 명시
		SELECT ENAME,JOB,SAL,COMM FROM EMP WHERE DEPTNO = P_DEPTNO;
	V_DEPTNO DEPT.DEPTNO%TYPE;
BEGIN
	V_DEPTNO := 20; -- 변수 값 대입
	FOR R_CUR_EMP IN CUR_EMP(V_DEPTNO) -- 커서에 변수 값 대입
	-- FOR R_CUR_EMP IN CUR_EMP(20) -- 변수 대입이 아닌, 상수값 대입 가능한가?
		LOOP
			INSERT INTO BONUS(ENAME,JOB,SAL,COMM)
			VALUES(R_CUR_EMP.ENAME,R_CUR_EMP.JOB,R_CUR_EMP.SAL,R_CUR_EMP.COMM);
		END LOOP;
	COMMIT;
END;
/
SELECT * FROM BONUS;

